= GNU Make项目管理笔记 =

== 第一章 ==
`makefile`告诉`make`需要做什么,该怎么做.他描述了工程中所有文件的编译顺序和规则.makefile有自己的书写格式,关键字及函数.
`make`是一个`命令工具`,解释`makefile`中的规则,根据makefile中的规则描述执行相关的命令来完成指定的任务.

make程序读入makefile文件，并且编译在文件中找到的`第一个`工作目标（默认目标）或命令行上指定的任何工作目标
make读取makefile以后会建立一个编译过程的描述数据库,此数据库中记录了所有各个文件之间的相互关系,以及他们的关系描述
make执行时,通过比较对应文件(规则的目标和依赖)的最后修改时间,来决定哪些文件需要更新,哪些文件不需要更新.

makefile中包含了一组用来编译应用程序的`规则`。make所看到的第一项规则会被作为`默认规则`使用

make检查目标的`依赖条件`,根据`命令`来创建或重建规则的`目标`

=== makefile规则组成 ===
{{{
Target...: Prerequisties...
<Tab>Commands
}}}

# 工作目标:通常是程序中间或者最后需要生成的文件名,可以是一个文件,也可以是一个make执行的动作的名称,如"clean",称这样的目标是"伪目标"
# 依赖条件：生成工作目标所需要的文件名列表.
# 所要执行的命令：用于根据必要条件创建工作目标的那些shell命令,必须以Tab键开头，make会将以TAB字符后面的内容作为命令来解释，由shell来执行。

=== 规则 ===
makefile中的`规则`就是描述在什么情况下,如何重建规则的目标文件.
规则包含了`目标`和`依赖`的关系以及更新目标所要求的`命令`.

== 目标 ==
当目标不是一个文件名时,称为`伪目标`,它仅仅代表了一个执行动作的标示.`他只有一个目的,就是通过这个目标名来执行他所定义的命令.`

=== 命令 ===
`命令`就是在任何一个目标的依赖文件发生变化后重建目标的动作描述.他描述了如何更新目标文件.

`一个规则可以有多个命令行,每个命令占一行.make会为每条命令启动一个shell来执行该命令.`

所有的命令行必须以<Tab>字符开始,但并不是所有以<Tab>字符出现的都是命令行,但make程序会把出现在第一条规则之后的所以以<Tab>字符开始的行都作为命令行来处理.

<red>一个目标可以没有依赖而只有动作,如"clean"伪目标.</red>

=== 编写规范 ===
makefile可以包含除规则以外的部分.一个简单的makefile可能只包含规则描述.

makefile文件一般使用"自上而下"的编写风格：一般来说，通用的工作目标会先在makefile文件中被制定，而细节会跟在后面。

编写makefile文件时，可以使用make命令的`--just-print(或-n)`选项，要求make`打印`他将为特定工作目标执行的命令，而不是实际执行这些命令

针对一个较长的规则,可以使用反斜线分解为多行,这样做可以使makefile清晰易读.`反斜线后面不能有空格`

对于makefile中的目标,执行make时首先执行`最终目标`所在的规则,接下来一层层的去寻找最终目标的`依赖文件`所在的规则并执行,
当最终目标的规则被完全的展开以后,make将从`最后`一个被展开的规则处开始执行,之后处理倒数第二个规则,依次`回退`,`最后`一步执行的就是`最终目标`所在的规则

*flex (The Fast Lexical Analyzer) 和 bison 工具的使用*
----

== 第二章 ==
规则分为两种类型:
- 显式规则：以特定的文件作为工作目标和必要条件,规则中明确给出目标文件,目标的依赖文件列表以及更新目标文件所需要的执行的命令.
- 隐含规则:由make程序根据规则目标文件的命名(典型的是文件名的后缀)而自动推导出来的规则.make根据目标文件的名字,自动产生目标的依赖文件并使用默认的命令对目标进行更新.

=== 通配符 ===
可以在`工作目标`，`必要条件`和`命令脚本`中使用通配符。
make使用的通配符与bash使用的简单通配符相同,为GLOB通配符：*,?,~,[...],[^...]
当模式出现在`工作目标`或`必要条件`中时，由`make`命令自动进行通配符的扩展，当模式出现在`命令脚本`中时，由`subshell`在执行命令时进行扩展动作

通配符除了在这种情况外的其他上下文中(如变量定义中),不能直接使用通配符,而是要通过函数"wildchar"来实现.

=== 假想工作目标 ===
任何`不代表文件`的工作目标就叫做假想工作目标
通常情况下，假想工作目标总会被执行，因为该规则的命令并不会创建目标文件。
.PHONY用来告诉make,该工作目标不是一个真正的文件，只是一个假想工作目标,从而可以避免假想工作目标与实际文件同名的问题。
{{{
.PHONY: clean
clean:
    rm -f *.o
}}}

=== make变量 ===
自动变量：
    make会在规则与他的`工作目标`和`必要条件`相符之后设定自动变量，用以通过自动变量访问工作目标和必要条件
    所以自动变量只能应用在规则中的`命令脚本`部分。
- $@    代表工作目标的文件名
- $%    档案文件成员结构中的文件名
- $<    第一个必要条件的文件名
- $?    比工作目标新的必要条件
- $^    所有的必要条件，去掉其中的重复文件
- $+    所有的必要条件，包括其中的重复文件
- $*    工作目标的文件名，去掉文件名后缀

=== VPATH ===
VPATH=dir-list
VPATH变量指定了依赖文件的搜索路径,在规则的依赖文件在当前目录下不存在时,make会在该变量所指定的目录下去寻找这些依赖文件.

该变量一般用于指定依赖文件的搜索目录,实际上VPATH指定的是makefile中所有文件的搜索目录,包括依赖文件和目标文件.但不适用规则的命令.

=== vpath ===
vpath pattern dir-list

=== 模式规则 ===
使用％表示任意多个任意字符。
make在进行模式规则匹配时，首先查找与模式规则相符的工作目标，如果找到，用％代表的字符替换必要条件列表％字符，然后对必要条件进行检查

=== 静态模式规则 ===
规定使用模式规则的特定文件
{{{
$(OBJECTS): %.o : %.c
    command
}}}  
只对$(OBJECTS)代表的文件使用模式匹配规则。

=== (隐含)内置规则 ===
使用--print-data-base(或-p)命令行选项查看支持的内置规则
当make检查一个工作目标时，如果找不到用于更新他的`具体规则`，就会使用隐含规则。
要使工作目标使用隐含规则，只要在makefile中添加工作目标后，`不指定`命令脚本就行。
一个没有指定命令脚本的模式会从make的数据库中删除相应的默认规则。

=== 双冒号规则 ===
通常，当一个工作目标多次出现时，所有的`必要条件`会被衔接成一个列表，而且只让一个命令脚本执行更新的动作
而对于双冒号规则而言，相同的工作目标每出现一次就会被视为一个独立的实体，必须进行独立的处理。
*对于同一个工作目标而言，所有的规则要么全都是双冒号规则，要么全都是单冒号规则*

----

== 第三章 ==
对表示用户在命令行上或环境中所自定义的常数型变量，习惯上变量名称全部大写
对于只在makefile中出现的变量，变量名全部小写。

注意变量赋值时会`保留`所有字`后面`的空格
=== 变量的类型 ===
`简单变量`：使用:=赋值运算符定义的变量
   make从makefile读进该变量的定义语句，赋值运算符的右边部分的变量引用会立刻被扩展，扩展后所产生的文本则会被存储为该变量的值。 
`递归变量`：使用＝赋值运算符定义的变量
   make读进赋值运算符右边的部分，并将之存储成该变量的值，但`不`进行任何的扩展，扩展的动作会被延迟到该变量被实际使用的时候才进行。 
   每当递归变量被使用的时候，make就会对他的右边部分进行重新求值的动作。

`宏变量`：使用define定义的变量
{{{
define variable
    command
endef
}}}

=== 变量的扩展 ===
`make执行规则：`
当make运行时，会以两个阶段来完成他的工作。

第一个阶段，make会读进makefile以及被引入的任何其他makefile.这个时候，其中所定义的变量 和规则会被加载进make的内部数据库，而且依存图也会被建立起来。

第二阶段，make会分析依存图，针对每项规则寻找工作目标，进行依存分析，然后执行脚本以完成所需要的更新动作。

`makefile中变量扩展准则：`
* 对于变量赋值，make会在第一阶段读进该行时，`立即`扩展赋值运算符`左边`的部分。
* =和?= 的`右边`部分会被`延后`到他们被使用的时候扩展，并且在第二阶段进行
* := 的`右边`部分会被立即扩展。
* 如果+= 的`左边`部分被定义成一个简单变量，+= 的右边部分会被立即扩展，否则他的求值动作会被延后。
* 对于宏定义，`宏的变量名`会被`立即扩展`，宏的`主体`会被`延后`到使用的时候扩展
* 对于规则，`工作目标`和`必要条件`会被`立即扩展`，然而`命令`总是会`延后扩展`。

{{{
IMMEDIATE = DEFERRED
IMMEDIATE ?= DEFERRED
IMMEDIATE := IMMEDIATE
IMMEDIATE += DEFERRED or IMMEDIATE
define IMMEDIATE
    DEFERRED
endef
IMMEDIATE:IMMEDIATE; DEFERRED
    DEFERRED

IMMEDIATE 表示变量会立即展开
DEFERRED 表示变量后被延后展开
}}}

`工作目标专属变量`
附加于工作目标之上，只有该工作目标及相应的任何必要条件被处理时，才会发生作用。
变量的赋值动作会延后到开始处理工作目标的时候进行。
{{{
target...: variable = value
target...: variable := value
target...: variable += value
target...: variable ?= value
}}}

`make的执行过程:`
# 依次读取变量"MAKEFILES"定义的makefile文件列表
# 读取工作目录下的makefile文件(根据命名的顺序查找"GNUmakefile", "makefile","Makefile",首先找到哪个就读哪个)
# 依次读取工作目录makefile文件中使用指示符"include"包含的文件
# 查找重建所有已读取的makefile文件的规则
# 初始化变量值并展开那些需要立即展开的变量和函数,并根据预设条件确定执行分支
# 根据"最终目标"以及其他目标的依赖关系建立依赖关系链表
# 执行除"最终目标"以外的所有的目标的规则
# 执行"最终目标"所在的规则

=== 变量的来源： ===
- 文件: 定义在makefile中或被makefile引入(include)
- 命令行： 在make命令行上定义或重新定义变量。命令行上变量的赋值结果将覆盖掉环境变量以及makefile文件中的赋值结果。
- 环境：当make启动时，所有来自环境的变量都会被自动定义成make的变量，makefile或命令行参数的赋值结果会覆盖掉环境变量的值。
- 自动创建：make会在执行一个规则的命令脚本之前立刻创建自动变量。

=== 条件指令 ===
{{{
if-condition
    text
else
    text
endif
}}}
if-condition可以是以下之一
- ifdef variable-name
- ifndef variable-name
- ifeq test
- ifneq test

进行ifdef/ifndef测试时，不应该以$()括住variable-name.
ifeq/ifneq用来测试其参数是否相等。其中test测试语句可以采用两种形式：
- (a, a)    小括号形式，只有逗号后的空格会被忽略，其他的所有空格都是有意义的。
- "a" "a"   引号形式

=== include指令 ===
使用include,makefile可以引入其他文件。常用来引入make头文件中所存放的共同的make定义，或是用来自动产生依存关系的信息。
include指令可以使用任意多个文件，shell通配符以及make变量。

== 第四章 ==
=== 字符处理函数 ===
- $(filter pattern...,text)        从text集合中过滤出符合pattern模板格式的字符串，可以使用通配符％
- $(filter-out pattern...,text)    与filter字符函数功能相反，可以使用通配符％
- $(findstring string...,text)     从text里搜索字符串string, 不能使用通配符％
- $(subst search-string,replace-string,text)   将text列表中出现search-string的地方替换为replace-string,不能使用通配符％
- $(patsubst search-pattern,replace-pattern,text)   与subst相似，可以使用通配符％

- $(words text) 返回text中单词的数量
- $(words n,text)   返回text中的第n个单词，第一个单词的编号是1
- $(firstword text) 返回text中的第一个单词
- $(wordlist start,end,text)    返回text中从start(含）到end(含）的单词
- $(sort list)  返回排序后的list 
- $(shell command)  返回command函数的返回值

=== 文件名函数 ===
$(whildcard pattern...)
$(dir list...)
$(notdir name...)
$(suffix name...)
$(basename name...)
$(addsuffix suffix,name...)
$(addprefix prefix,name...)
$(join prefix-list,suffix-list)

=== 流程控制 ===
$(if condition,then-part,else-part)     判断condition扩展之后是否包含任何字符，如果有，则执行then-part,否则执行else-part
$(error text)
$(foreach variable,list,body)

=== 其他 ===
$(strip text)       去掉text中所有前导和接在后面的空格
$(origin variable)  返回描述变量来自何处的字符串
$(warning text)     显示警告信息，不会导致make结束运行

== 第五章 ==
在工作目标之后，凡是以<Tab>开头的文本行一律会被视为命令（除非前一行的结尾是一个反斜线符号）
每行命令都会在他自己的shell中执行。
=== 命令修饰符 ===
- `@`   不要输出命令
- `-`   忽略命令中的错误
- `+`   要求make执行命令，即使是通过-n选项来执行make的。
