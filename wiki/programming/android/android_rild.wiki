%template code_3
%toc

= Android RILD分析 =

我们知道，现在大多数的手机实现有两个处理器组成：AP和BP,AP为Application Processor简称，负责运行应用程序，而BP即Baseband Processor则专门负责无线通信，两个处理器之间使用AT指令通信。而每个BP的生产商实现的AT指令又可能差异很大，而且多数因为商业的原因不会公开源码而是以共享库的方式提供。本文中分析的rild为AP与BP搭建了沟通的桥梁：rild运行与AP中，通过加载生产商提供的rillib共享库，将AP与BP通过AT指令连接起来。

RILD进程由linux系统在启动时加载并启动。具体看init.rc文件:
init.rc
{{{class="brush: bash"
......

service ril-daemon /system/bin/rild
    class main
    socket rild stream 660 root radio
    socket rild-debug stream 660 radio system
    user root
    group radio cache inet misc audio sdcard_rw log

......
}}}
init.rc文件分析请看[[android_init|Android启动篇]],这里只需要明白，linux系统启动时，会启动/system/bin/rild进程服务，该服务的名字是rild-daemon,关爱服务会启动两个socket:rild socket和rild-debug socket

`rild.c`
{{{class="brush: c"
int main(int argc, char **argv)
{
    const char * rilLibPath = NULL;
    char **rilArgv;
    void *dlHandle;
    const RIL_RadioFunctions *(*rilInit)(const struct RIL_Env *, int, char **);
    const RIL_RadioFunctions *funcs;
    char libPath[PROPERTY_VALUE_MAX];
    unsigned char hasLibArgs = 0;

    int i;

    umask(S_IRGRP | S_IWGRP | S_IXGRP | S_IROTH | S_IWOTH | S_IXOTH);
    
    ......

    switchUser();
    //rilLibPath实际的rillib路径，这里我们以android的reference来分析
    //#define  REFERENCE_RIL_PATH  "/system/lib/libreference-ril.so"
    
    //(1)
    dlHandle = dlopen(rilLibPath, RTLD_NOW);

    ......
    //(2)
    RIL_startEventLoop();

    //(3)
    rilInit = (const RIL_RadioFunctions *(*)(const struct RIL_Env *, int, char **))dlsym(dlHandle, "RIL_Init");
    ......
    funcs = rilInit(&s_rilEnv, argc, rilArgv);
    
    //(3)
    RIL_register(funcs);
    ......
}
}}}

我们将rild的实现过程归结为3步：

== 1, 加载rillib共享库 ==
使用dlopen系统调用，动态加载提供的rillib共享库，由于每个生产商提供的libril共享库的实现都不同，这里我们以android rillib的参考实现作为分析的目标，他的路径是:"/system/lib/libreference-ril.so"，实现文件在reference-ril.c中。dlopen返回打开的共享库的句柄，可以通过该句柄获取共享库中的符号连接。

----
== 2, 搭建ril_event事件分发处理框架 ==
在介绍这个框架之前，我们需要再次明确rild所需要完成的工作 ，这有助于我们理解rild架构的实现。
# rild需要及时接收RILJ发送过来的请求
# rild需要将RILJ发送的请求及时通过libril发送给Modem
# rild需要监控libril发送过来的响应
# rild需要及时将请求的响应发送到RILJ
# rild需要将libril发送过来的Modem主动上报信息及时通知到RILJ 

从这里来看，rild的主要工作是处理RILJ和libril(Modem）发送过来的事件，为此，rild开启了一个单独的线程，来接受两方面发送过来的事件。

`ril.cpp`
{{{class="brush: cpp"
extern "C" void
RIL_startEventLoop(void) {
    int ret;
    pthread_attr_t attr;

    /* spin up eventLoop thread and wait for it to get started */
    s_started = 0;
    pthread_mutex_lock(&s_startupMutex);

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    //创建一个线程，运行eventLoop
    ret = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);

    while (s_started == 0) {
        //等待eventLoop线程运行起来
        pthread_cond_wait(&s_startupCond, &s_startupMutex);
    }

    pthread_mutex_unlock(&s_startupMutex);

    if (ret < 0) {
        LOGE("Failed to create dispatch thread errno:%d", errno);
        return;
    }
}
}}}
线程的名称是s_tid_dispatch,入口函数是eventLoop,记住这个线程的名字，后面还会碰到好几个线程。而eventLoop中就是rild事件分发处理的重点。该线程为rild搭建了一个事件处理框架，将RILJ和Modem发送过来的信息都作为一个ril_event,储存在自己的ril_event列表中，通过select多路复用机制，对列表中的事件进行处理。

`ril.cpp`
{{{class="brush: cpp"
static void *
eventLoop(void *param) {
    int ret;
    int filedes[2];

    //(1)初始化ril event使用的数据结构
    ril_event_init();

    pthread_mutex_lock(&s_startupMutex);

    s_started = 1;
    pthread_cond_broadcast(&s_startupCond);
    //当该线程运行起来后，置标志位通知启动线程当前线程已经启动起来了

    pthread_mutex_unlock(&s_startupMutex);

    //(2)创建匿名管道
    ret = pipe(filedes);

    ......
    //保存匿名管道的读写端，
    s_fdWakeupRead = filedes[0];
    s_fdWakeupWrite = filedes[1];

    //设置读端口属性为非阻塞
    fcntl(s_fdWakeupRead, F_SETFL, O_NONBLOCK);

    //初始化s_wakeupfd_event ril_event
    ril_event_set (&s_wakeupfd_event, s_fdWakeupRead, true,
                processWakeupCallback, NULL);
    //将s_wakeupfd_event添加到监控列表中
    rilEventAddWakeup (&s_wakeupfd_event);

    // Only returns on error
    //(3)启动ril_event事件循环
    ril_event_loop();

    return NULL;
}
}}}

==== 2.1 对ril_event列表及select多路复用的读端口进行初始化，为后面的循环框架做准备 ====
`ril_event.cpp`
{{{class="brush: cpp"
void ril_event_init()
{
    MUTEX_INIT();                   //初始化互斥量

    FD_ZERO(&readFds);              //清空读端口集
    init_list(&timer_list);         //初始化timer_list
    init_list(&pending_list);       //初始化pending_list
    memset(watch_table, 0, sizeof(watch_table));    //初始化watch_table
}
}}}

这里面涉及到4个主要变量，下面对他们逐个说明
# readFds:  RILJ发送过来的请求会被封装为ril_event,该ril_event中也包含了发送请求的socket句柄，每个请求的句柄会被添加到该读端口集合中，以便在select多路复用对句柄进行检测
# timer_list:   负责维护定时任务，一般是rild收到libril发送过的信息会被放到该列表中，由于rild对RILJ请求回复机制采用的是异步模式，所以RILJ的请求回复与Modem的主动上报信息会被rild一样对待
# pending_list: 负责维护准备处理的任务，timer_list中到时的任务他watch_table中的任务会被添加到pending_list,存在与pending_list中的任务会在这一轮事件循环中进行处理
# watch_table:  负责维护RILJ发送过来的请求和框架自身的事件。

==== 2.2 创建匿名管道，并添加到watch_table中 ====
创建一对匿名管道，封装到s_wakeupfd_event事件，通过rilEventAddWakeup函数将事件添加到watch_table中。
在分析rilEventAddWakeup(）之前，先来看看ril_event定义
`ril_event.h`
{{{class="brush: cpp"
struct ril_event {
    struct ril_event *next;
    struct ril_event *prev;

    int fd;     //关联的文件句柄，表明从哪个文件读取的数据
    int index;  //事件索引
    bool persist;   //是否保持，false时，在处理完该事件后，就将该事件从watch_table中删除，反之则不删除
    struct timeval timeout; //超时时间
    ril_event_cb func;      //事件触发后的回调函数
    void *param;            //回调函数的参数
};
}}}
rilEventAddWakeup(）函数将ril_event添加到watch_table中，然后将事件关联的句柄添加到readFds句柄集中，供后面的select使用，最后会通过triggerEvLoop(）通过向写管道中写入数据触发一轮事件处理。
{{{class="brush: cpp"
static void rilEventAddWakeup(struct ril_event *ev) {
    ril_event_add(ev);
    triggerEvLoop();
}
void ril_event_add(struct ril_event * ev)
{
    MUTEX_ACQUIRE();
    for (int i = 0; i < MAX_FD_EVENTS; i++) {
        if (watch_table[i] == NULL) {
            watch_table[i] = ev;
            ev->index = i;
            FD_SET(ev->fd, &readFds);   //将文件句柄添加到句柄集中
            if (ev->fd >= nfds) nfds = ev->fd+1;    //设置句柄集中的句柄的数量
            break;
        }
    }
    MUTEX_RELEASE();
}
static void triggerEvLoop() {
    int ret;
    //当其他的线程使用该函数时，向匿名管道的写端口写入数据，触发一次select处理循环
    if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
        /* trigger event loop to wakeup. No reason to do this,
         * if we're in the event loop thread */
         do {
            ret = write (s_fdWakeupWrite, " ", 1);
         } while (ret < 0 && errno == EINTR);
    }
}
}}}

==== 2.3 启动事件处理循环 ====
前面我们说过readFds,现在就是他施展拳脚的时候了，通过使用select机制监控readFds,触发事件。
`ril_event.cpp`
{{{class="brush: cpp"
void ril_event_loop()
{
    int n;
    fd_set rfds;
    struct timeval tv;
    struct timeval * ptv;

    //循环处理事件
    for (;;) {

        //因为readFds并不是线程安全的，这里做一份拷贝，防止在select等待时readFds被修改
        memcpy(&rfds, &readFds, sizeof(fd_set));
        //判断当前时间
        if (-1 == calcNextTimeout(&tv)) {
            // no pending timers; block indefinitely
            ptv = NULL;
        } else {
            ptv = &tv;
        }
        
        //对rfds集合中的句柄进行监控
        n = select(nfds, &rfds, NULL, NULL, ptv);
        if (n < 0) {
            if (errno == EINTR) continue;

            LOGE("ril_event: select error (%d)", errno);
            // bail?
            return;
        }
        //将超时事件添加到pending_list
        processTimeouts();
        //将watch_table中的事件添加到pending_list
        processReadReadies(&rfds, n);
        //调用pending_list中的事件处理函数
        firePending();
    }
}
}}}
函数等待readFds读集合中有数据可读，当有数据可读时，将timer_list和watch_table中的ril_event添加到pending_list中，
{{{class="brush: cpp"
static void processTimeouts()
{
    MUTEX_ACQUIRE();
    struct timeval now;
    struct ril_event * tev = timer_list.next;
    struct ril_event * next;

    getNow(&now);
    // walk list, see if now >= ev->timeout for any events
    //查询timer_list中所有的ril_event,当已经到时间的ril_event从timer_list中转移到pending_list中，准备处理
    while ((tev != &timer_list) && (timercmp(&now, &tev->timeout, >))) {
        // Timer expired
        next = tev->next;
        removeFromList(tev);
        addToList(tev, &pending_list);
        tev = next;
    }
    MUTEX_RELEASE();
}
static void processReadReadies(fd_set * rfds, int n)
{
    MUTEX_ACQUIRE();

    //检查watch_table中的ril_event,如果他们的fd可读，将其添加到pending_list中，然后根据persist属性，决定是否从watch_table中删除该ril_event
    for (int i = 0; (i < MAX_FD_EVENTS) && (n > 0); i++) {
        struct ril_event * rev = watch_table[i];
        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
            addToList(rev, &pending_list);
            if (rev->persist == false) {
                removeWatch(rev, i);
            }
            n--;
        }
    }

    MUTEX_RELEASE();
}
}}}
最后调用firePending(）处理pending_list中的ril_event
{{{class="brush: cpp"
static void firePending()
{
    struct ril_event * ev = pending_list.next;
    while (ev != &pending_list) {
        struct ril_event * next = ev->next;
        removeFromList(ev);
        ev->func(ev->fd, 0, ev->param);
        ev = next;
    }
}
}}}
做个总结：
rild启动线程s_tid_dispatch,等待readFds集合中有描述符可读，一旦select返回，便处理watch_list和pending_list中的事件，调用这些事件的处理函数。其他线程可以通过rilEventAddWakeup()函数将事件添加到watch_list,该函数会自动将新添加的ril_event的文件句柄添加到readFds中，同时，该函数还会通过往匿名管道写端s_fdWakeupWrite中写入数据，使readFds中匿名管道读端描述符s_fdWakeupRead可读，从而触发select返回。

再来个eventLoop的处理流程图，也从网上K来的

{{../../../public/images/ril_eventloop1.jpg}}
再来一张

{{../../../public/images/ril_eventloop2.jpg}}

s_tid_dispatch线程启动后，便会阻塞在select(）调用，此时readFds集合中只有s_fdWakeupRead描述符，等待其他线程通过s_fdWakeupWrite端口写入数据来激活s_tid_dispatch线程进行事件处理。

----
== 3, 初始化libril==
RIL_Init是所有的libril共享库必须提供的函数，rild通过调用这个函数，使用libril共享库完成对Modem设备的操作。

在开始具体的代码分析之前，我们还是先考虑一下libril的工作任务：
rild使用libril，实现发送指令给通信模块并获取指令响应以及获取通信模块上报的信息。而libril由生产商为不同的通信模块量身定制，其具体实现对于rild来说是透明的。rild如何将命令发送到libril而libril又如何将处理结果发送给rild的呢？

android采用rild负责定义输出规范，而libril负责定义输入规范的方式解决这个问题，rild通过libril定义的输入规范将命令发送到libril,libril在处理完后，将处理结果按照rild定义的输出规范发送出来。

知道了他的实现方式后，我们看代码就比较容易了，首先看看rillib提供的RIL_Init(）注册函数：

`reference-ril.c`
{{{class="brush: c"
pthread_t s_tid_mainloop;

const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv)
{
    int ret;
    int fd = -1;
    int opt;
    pthread_attr_t attr;

    //将rild发送过来的回调函数保存下来，供libril以后调用
    s_rilenv = env;

    ......

    pthread_attr_init (&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&s_tid_mainloop, &attr, mainLoop, NULL);

    return &s_callbacks;
}
}}}

1. 函数接收一个RIL_Env结构指针，该结构就是rild定义的输出规范，由rild实现，由libril调用，向rild发送请求处理结果或主动上报信息

`rild.c`
{{{class="brush: c"
static struct RIL_Env s_rilEnv = {
    RIL_onRequestComplete,      //处理非主动命令时libril的回调函数
    RIL_onUnsolicitedResponse,  //处理主动命令时libril的回调函数
    RIL_requestTimedCallback    //处理超时请求时libril的回调函数
};
}}}

1.1 RIL_onUnsolicitedResponse(）用于处理主动上报命令。
{{{class="brush: cpp"
extern "C"
void RIL_onUnsolicitedResponse(int unsolResponse, void *data,
                                size_t datalen)
{
    int unsolResponseIndex;
    int ret;
    int64_t timeReceived = 0;
    bool shouldScheduleTimeout = false;

    if (s_registerCalled == 0) {
        // Ignore RIL_onUnsolicitedResponse before RIL_register
        LOGW("RIL_onUnsolicitedResponse called before RIL_register");
        return;
    }

    unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;

    if ((unsolResponseIndex < 0)
        || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
        LOGE("unsupported unsolicited response code %d", unsolResponse);
        return;
    }

    // Grab a wake lock if needed for this reponse,
    // as we exit we'll either release it immediately
    // or set a timer to release it later.
    switch (s_unsolResponses[unsolResponseIndex].wakeType) {
        case WAKE_PARTIAL:
            grabPartialWakeLock();
            shouldScheduleTimeout = true;
        break;

        case DONT_WAKE:
        default:
            // No wake lock is grabed so don't set timeout
            shouldScheduleTimeout = false;
            break;
    }

    // Mark the time this was received, doing this
    // after grabing the wakelock incase getting
    // the elapsedRealTime might cause us to goto
    // sleep.
    if (unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
        timeReceived = elapsedRealtime();
    }

    appendPrintBuf("[UNSL]< %s", requestToString(unsolResponse));

    Parcel p;

    p.writeInt32 (RESPONSE_UNSOLICITED);    //写入请求的类型
    p.writeInt32 (unsolResponse);       //写入请求的ID

    //s_unsolResponses是一个数组。里面包含所有rild支持的主动上报请求及其相应的处理函数
    ret = s_unsolResponses[unsolResponseIndex]
                .responseFunction(p, data, datalen);
    if (ret != 0) {
        // Problem with the response. Don't continue;
        goto error_exit;
    }

    // some things get more payload
    switch(unsolResponse) {
        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
            p.writeInt32(s_callbacks.onStateRequest());
            appendPrintBuf("%s {%s}", printBuf,
                radioStateToString(s_callbacks.onStateRequest()));
        break;


        case RIL_UNSOL_NITZ_TIME_RECEIVED:
            // Store the time that this was received so the
            // handler of this message can account for
            // the time it takes to arrive and process. In
            // particular the system has been known to sleep
            // before this message can be processed.
            p.writeInt64(timeReceived);
        break;
    }

    //将p通过s_fdCommand socket发送出去
    ret = sendResponse(p);
    ......
    return;

error_exit:
    if (shouldScheduleTimeout) {
        releaseWakeLock();
    }
}
}}}

1.2 <a name="tag_onrequestcomplete">RIL_onRequestComplete()</a>在libril处理非主动命令时调用，将处理结果通过socket发送到RILJ
{{{class="brush: cpp"
extern "C" void
RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen) {
    RequestInfo *pRI;
    int ret;
    size_t errorOffset;

    pRI = (RequestInfo *)t;

    if (!checkAndDequeueRequestInfo(pRI)) {
        LOGE ("RIL_onRequestComplete: invalid RIL_Token");
        return;
    }

    if (pRI->local > 0) {
        // Locally issued command...void only!
        // response does not go back up the command socket
        LOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));

        goto done;
    }

    appendPrintBuf("[%04d]< %s",
        pRI->token, requestToString(pRI->pCI->requestNumber));

    if (pRI->cancelled == 0) {
        Parcel p;

        p.writeInt32 (RESPONSE_SOLICITED);  //写入请求的类型
        p.writeInt32 (pRI->token);          //写入请求的序列号
        errorOffset = p.dataPosition();

        p.writeInt32 (e);

        if (response != NULL) {
            //将modem反馈的请求结果进行初步处理处理
            ret = pRI->pCI->responseFunction(p, response, responselen);

            /* if an error occurred, rewind and mark it */
            if (ret != 0) {
                p.setDataPosition(errorOffset);
                p.writeInt32 (ret);
            }
        }

        if (e != RIL_E_SUCCESS) {
            appendPrintBuf("%s fails by %s", printBuf, failCauseToString(e));
        }

        if (s_fdCommand < 0) {
            LOGD ("RIL onRequestComplete: Command channel closed");
        }
        //通过s_fdCommand将p发送到RILJ
        sendResponse(p);
    }

done:
    free(pRI);
}
}}}


2. 函数返回一个RIL_RadioFunctions结构指针，该结构是libril定义的输入规范，由libril实现，由rild调用，用来向libril发送请求。

`ril.h`
{{{class="brush: c"
typedef struct {
    int version;        /* set to RIL_VERSION */
    RIL_RequestFunc onRequest;
    RIL_RadioStateRequest onStateRequest;
    RIL_Supports supports;
    RIL_Cancel onCancel;
    RIL_GetVersion getVersion;
} RIL_RadioFunctions;
}}}


3. 函数创建了一个新的线程s_tid_mainloop,该线程的入口函数mainLoop(）。注意libril只是一个共享库文件，函数实际在rild进程中运行。线程的主要任务是获取AT串口设备句柄，用于后续通过该句柄发送命令给通信模块，并启动监听该句柄，当Modem通过句柄发送信息过来时，进行处理。

`reference-ril.c`
{{{class="brush: c"
static void *
mainLoop(void *param)
{
    int fd;
    int ret;

    //设置AT读端口关闭时的处理函数
    at_set_on_reader_closed(onATReaderClosed);
    //设置AT指令超时的处理函数 
    at_set_on_timeout(onATTimeout);

    for (;;) {
        fd = -1;
        while  (fd < 0) {
            //略过打开AT串口设备fd
            ...... 

            if (fd < 0) {
                perror ("opening AT interface. retrying...");
                sleep(10);
                /* never returns */
            }
        }

        s_closed = 0;
        //(1)
        ret = at_open(fd, onUnsolicited);

        if (ret < 0) {
            LOGE ("AT error %d on at_open\n", ret);
            return 0;
        }
        //(2)
        RIL_requestTimedCallback(initializeCallback, NULL, &TIMEVAL_0);

        // Give initializeCallback a chance to dispatched, since
        // we don't presently have a cancellation mechanism
        sleep(1);

        //等待AT模块关闭
        waitForClose();
    }
}
}}}
下面拿出两个关键的函数来分析：

==== 3.1 创建读取at串口设备的工作线程 ====
at_open()函数会创建一个<a name="tag_s_tid_reader">s_tid_reader</a>线程，入口函数是readerLoop(）,该线程的主要工作是不断的读取串口设备发送过来的数据，并进行处理。

`atchannel.c`
{{{class="brush: c"
int at_open(int fd, ATUnsolHandler h)
{
    ......
    
    s_fd = fd;
    s_unsolHandler = h; 

    ......
    
    pthread_attr_init (&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&s_tid_reader, &attr, readerLoop, &attr);
    ......
}

static void *readerLoop(void *arg)
{
    for (;;) {
        const char * line;

        //从串口中不断的读取数据，直到读取一行数据
        line = readline();

        if (line == NULL) {
            //当无法读取到完整的指令时，退出循环
            break;
        }

        //对短信命令（+CMT,+CDS,+CBM）处理
        if(isSMSUnsolicited(line)) {
            char *line1;
            const char *line2;

            // The scope of string returned by 'readline()' is valid only
            // till next call to 'readline()' hence making a copy of line
            // before calling readline again.
            line1 = strdup(line);
            line2 = readline();

            if (line2 == NULL) {
                break;
            }

            if (s_unsolHandler != NULL) {
                s_unsolHandler (line1, line2);
            }
            free(line1);
        } else {
            //对该行数据进行处理
            processLine(line);
        }
        ......
    }

    //通知读取信息失败
    onReaderClosed();
    return NULL;
}
}}}
processLine(）用于对从串口读回的每行数据进行处理
{{{class="brush: c"
static void processLine(const char *line)
{
    pthread_mutex_lock(&s_commandmutex);

    if (sp_response == NULL) {
        //sp_response=NULL表示当前没有命令发出，所以为modem的主动上报信息
        handleUnsolicited(line);
    } else if (isFinalResponseSuccess(line)) {
        //命令最终处理结果：返回SUCCESS
        sp_response->success = 1;
        handleFinalResponse(line);
    } else if (isFinalResponseError(line)) {
        //命令最终处理结果：返回ERROR
        sp_response->success = 0;
        handleFinalResponse(line);
    } else if (s_smsPDU != NULL && 0 == strcmp(line, "> ")) {
        //发送短信的AT命令的特殊处理
        // See eg. TS 27.005 4.3
        // Commands like AT+CMGS have a "> " prompt
        writeCtrlZ(s_smsPDU);
        s_smsPDU = NULL;
    } else switch (s_type) {
        case NO_RESULT:
            //当前命令不会导致modem反馈处理结果，此时读到的信息作为主动上报信息处理
            handleUnsolicited(line);
            break;
        case NUMERIC:
            //判断是否是当前命令的处理结果，如果是，则保存处理结果，否则作为主动上报信息处理
            if (sp_response->p_intermediates == NULL
                && isdigit(line[0])
            ) {
                addIntermediate(line);
            } else {
                handleUnsolicited(line);
            }
            break;
        case SINGLELINE:
            //判断是否是当前命令的处理结果，如果是，则保存处理结果，否则作为主动上报信息处理
            if (sp_response->p_intermediates == NULL
                && strStartsWith (line, s_responsePrefix)
            ) {
                addIntermediate(line);
            } else {
                handleUnsolicited(line);
            }
            break;
        case MULTILINE:
            //判断是否是当前命令的处理结果，如果是，则保存处理结果，否则作为主动上报信息处理
            if (strStartsWith (line, s_responsePrefix)) {
                addIntermediate(line);
            } else {
                handleUnsolicited(line);
            }
        break;

        default: /* this should never be reached */
            LOGE("Unsupported AT command type %d\n", s_type);
            handleUnsolicited(line);
        break;
    }

    pthread_mutex_unlock(&s_commandmutex);
}
}}}
从这里的处理来看，s_tid_reader线程在读到数据后，会根据当前命令的状态判断读到的数据是当前命令的处理结果还是modem主动上报的信息，主动命令由handleUnsolicited(）函数处理，命令的处理结果则是由handleFinalResponse(）函数处理。

`atchannel.c`

{{{class="brush: c"
static void handleFinalResponse(const char *line)
{
    sp_response->finalResponse = strdup(line);
    
    发送s_commandcond信号，通知正在等待处理结果的at_send_command_full_nolock()函数。
    pthread_cond_signal(&s_commandcond);
}
}}}
{{{class="brush: c"
//主动上报信息的处理
static void handleUnsolicited(const char *line)
{
    if (s_unsolHandler != NULL) {
        s_unsolHandler(line, NULL);
    }
}
}}}
非主动上报的命令处理时，只是将s_commandcond信号发送出去，此时，发送命令的线程正在等待获取该信号以进一步处理。这部分会在后面看到。

对于主动上报的信息，调用了s_unsolHandler(）函数处理，而该函数是在libril的RIL_Init(）函数中，打开at设备时传入的。

`reference-ril.c`
{{{class="brush: c"
void main(){
    ......

    s_closed = 0;
    ret = at_open(fd, onUnsolicited);

    if (ret < 0) {
        LOGE ("AT error %d on at_open\n", ret);
        return 0;
    }
    ......
}
}}}
`atchannel.c`
{{{class="brush: c"
int at_open(int fd, ATUnsolHandler h)
{
    int ret;
    pthread_t tid;
    pthread_attr_t attr;

    s_fd = fd;
    s_unsolHandler = h;
    s_readerClosed = 0;
}}}

onUnsolicited()函数用于处理通过modem读取到的主动上报信息。运行在atchannel的reader线程中。

`reference-ril.c`
{{{class="brush: c"
static void onUnsolicited (const char *s, const char *sms_pdu)
{
    char *line = NULL;
    int err;

    /* Ignore unsolicited responses until we're initialized.
     * This is OK because the RIL library will poll for initial state
     */
    if (sState == RADIO_STATE_UNAVAILABLE) {
        return;
    }

    if (strStartsWith(s, "%CTZV:")) {
        /* TI specific -- NITZ time */
        char *response;

        line = strdup(s);
        at_tok_start(&line);

        err = at_tok_nextstr(&line, &response);

        if (err != 0) {
            LOGE("invalid NITZ line %s\n", s);
        } else {
            RIL_onUnsolicitedResponse (
                RIL_UNSOL_NITZ_TIME_RECEIVED,
                response, strlen(response));
        }
    } else if (strStartsWith(s,"+CRING:")
                || strStartsWith(s,"RING")
                || strStartsWith(s,"NO CARRIER")
                || strStartsWith(s,"+CCWA")
    ) {
        RIL_onUnsolicitedResponse (
            RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED,
            NULL, 0);
#ifdef WORKAROUND_FAKE_CGEV
        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL); //TODO use new function
#endif /* WORKAROUND_FAKE_CGEV */
    } else if (strStartsWith(s,"+CREG:")
                || strStartsWith(s,"+CGREG:")
    ) {
        RIL_onUnsolicitedResponse (
            RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED,
            NULL, 0);
#ifdef WORKAROUND_FAKE_CGEV
        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL);
#endif /* WORKAROUND_FAKE_CGEV */
    } else if (strStartsWith(s, "+CMT:")) {
        RIL_onUnsolicitedResponse (
            RIL_UNSOL_RESPONSE_NEW_SMS,
            sms_pdu, strlen(sms_pdu));
    } else if (strStartsWith(s, "+CDS:")) {
        RIL_onUnsolicitedResponse (
            RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT,
            sms_pdu, strlen(sms_pdu));
    } else if (strStartsWith(s, "+CGEV:")) {
        /* Really, we can ignore NW CLASS and ME CLASS events here,
         * but right now we don't since extranous
         * RIL_UNSOL_DATA_CALL_LIST_CHANGED calls are tolerated
         */
        /* can't issue AT commands here -- call on main thread */
        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL);
#ifdef WORKAROUND_FAKE_CGEV
    } else if (strStartsWith(s, "+CME ERROR: 150")) {
        RIL_requestTimedCallback (onDataCallListChanged, NULL, NULL);
#endif /* WORKAROUND_FAKE_CGEV */
    }
}
}}}

最终函数调用RIL_onUnsolicitedResponse()，通过这种方式,libril调用到了rild的RIL_onUnsolicitedResponse(）。该函数的分析请看 <a href="#tag_ril_env">【这里】</a>

至于非主动命令的处理，会在下面发送请求的部分详细分析。

总结：
通过调用at_open(）函数，rild此时有了读取AT串口设备并对数据进行处理的能力。此时可以处理AT请求及通信设备的主动上报信息。但此时mainLoop(）还没有执行完呢，接下来

==== 3.2 初始化AT设备==== 

打通串口设备数据通路后，就该对通信设备进行初始化了。这个工作是由RIL_requestTimedCallback宏完成，还记得前面调用RIL_Init(）函数时传入的RIL_Env结构吧，这个宏其实就调用了该结构的RequestTimedCallback(）函数指针。

`reference-ril.c`
{{{class="brush: c"
#define RIL_requestTimedCallback(a,b,c) s_rilenv->RequestTimedCallback(a,b,c)
}}}
你应该还记得RIL_Env的功能，他由rild定义，由libril调用，主要用于libril向rild反馈modem的主动上报信息，libril通过调用该函数，通知rild在ril_event列表中添加一个定时事件，事件具体的工作内容在userTimerCallback(）中，定的时间是TIMEVAL_0=0,即立即执行。下面看看他的具体实现：

`ril.cpp`
{{{class="brush: cpp"
extern "C" void
RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
                                const struct timeval *relativeTime) {
    internalRequestTimedCallback (callback, param, relativeTime);
}

static UserCallbackInfo *
internalRequestTimedCallback (RIL_TimedCallback callback, void *param,
                                const struct timeval *relativeTime)
{
    struct timeval myRelativeTime;
    UserCallbackInfo *p_info;

    p_info = (UserCallbackInfo *) malloc (sizeof(UserCallbackInfo));

    p_info->p_callback = callback;
    p_info->userParam = param;

    if (relativeTime == NULL) {
        /* treat null parameter as a 0 relative time */
        memset (&myRelativeTime, 0, sizeof(myRelativeTime));
    } else {
        /* FIXME I think event_add's tv param is really const anyway */
        memcpy (&myRelativeTime, relativeTime, sizeof(myRelativeTime));
    }

    //创建一个ril_event,添加到timer_list中
    ril_event_set(&(p_info->event), -1, false, userTimerCallback, p_info);

    ril_timer_add(&(p_info->event), &myRelativeTime);
    //触发s_tid_dispatch线程进行事件处理    
    triggerEvLoop();
    return p_info;
}
}}}
这里的tiggerEvLoop(）可不是在rild的s_tid_dispatch中拿来唬人的啦，当前的线程可是s_tid_mainloop,所以该函数在这里可动真刀枪了。

`ril.cpp`
{{{class="brush: cpp"
static void triggerEvLoop() {
    int ret;
    if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
    //当前线程是s_tid_mainloop,所以走这里
         do {
            ret = write (s_fdWakeupWrite, " ", 1);
         } while (ret < 0 && errno == EINTR);
    }
}
}}}
tiggerEvLoop(）向s_fdWakeupWrite写入一个字节数据，s_tid_dispatch线程在望穿秋水的等待中终于等来了第一个客户，于是立马开动，遍历timer_list,里面已经有了RIL_requestTimedCallback()函数添加的ril_event,于是赶紧比较时间，发现时间预定的时间到了，于是马不停蹄，将事件从timer_list取出并添加到pending_list,并立即遍历pending_list,调用pending_list中该ril_event的回调函数userTimerCallback(），回调函数最终调用initializeCallback(）,该函数通过发送多条AT指令来初始化AT设备。

{{{class="brush: c"
static void initializeCallback(void *param)
{
    ATResponse *p_response = NULL;
    int err;

    setRadioState (RADIO_STATE_OFF);

    at_handshake();

    /* note: we don't check errors here. Everything important will
       be handled in onATTimeout and onATReaderClosed */

    /*  atchannel is tolerant of echo but it must */
    /*  have verbose result codes */
    at_send_command("ATE0Q0V1", NULL);

    /*  No auto-answer */
    at_send_command("ATS0=0", NULL);

    /*  Extended errors */
    at_send_command("AT+CMEE=1", NULL);

    /*  Network registration events */
    err = at_send_command("AT+CREG=2", &p_response);

    ......

    /* assume radio is off on error */
    if (isRadioOn() > 0) {
        setRadioState (RADIO_STATE_SIM_NOT_READY);
    }
}
}}}

==== 3.3 等待设备关闭信号 ====
mainLoop是一个无限循环，在打开AT设备并完成设备初始化后，就使用waitForClose(）函数使线程进入等待设备关闭的信号状态，当设备关闭时，再重新打开设备并初始化。

`reference-ril.c`
{{{class="brush: c"
static void waitForClose()
{
    pthread_mutex_lock(&s_state_mutex);

    //等待s_state_cond信号
    while (s_closed == 0) {
        pthread_cond_wait(&s_state_cond, &s_state_mutex);
    }

    pthread_mutex_unlock(&s_state_mutex);
}
}}}

总结：
libril提供的RIL_Init(）函数启动了一个线程：s_tid_mainloop,该线程做了三个工作：
# 打开AT串口设备
# 创建一个新的线程s_tid_reader,用来不断的读取串口发送的数据
# 初始化通信设备
# 等待串口关闭的信号，在收到这个信号后，重新进行上面的步骤1。

== 4. 监控rild socket,准备接受RILJ socket连接 ==
通过上面3步，rild已经创建了事件的处理框架，做好了准备工作，就可以打通RILJ的通路，接收RILJ发送过来的指令了。从RILJ的分析中，我们就已经知道RILJ与rild使用socket通信。rild便是RILJ的服务端。

`rild.c`
{{{class="brush: cpp"
extern "C" void
RIL_register (const RIL_RadioFunctions *callbacks) {
    int ret;
    int flags;

    ......

    //保存rillib提供的回调函数
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));

    s_registerCalled = 1;

    ......
    
    //获取rild socket
    s_fdListen = android_get_control_socket(SOCKET_NAME_RIL);
    if (s_fdListen < 0) {
        exit(-1);
    }

    //使socket处于被动监听状态
    ret = listen(s_fdListen, 4);

    if (ret < 0) {
        exit(-1);
    }

    ril_event_set (&s_listen_event, s_fdListen, false,
                listenCallback, NULL);

    //将监听事件添加到rild的事件循环中
    rilEventAddWakeup (&s_listen_event);
    ......
}
}}}

RIL_register使用linux的socket编程方式，创建名为SOCKET_NAME_RIL的socket,并使其处于被动监听状态，准备接受RILJ发来的socket连接，然后使用该socket为文件句柄创建了一个ril_event,通过rilEventAddWakeup(）函数通知s_tid_dispatch线程，前面说过rild创建了s_tid_dispatch线程后，该线程就在那里望穿秋水的等着s_fdWakeupRead管道有数据过来，前面处理了一次定时任务initializeCallback(）事件后，又没事可干了，现在终于又接了一单生意，我们在这里梳理一下，他是如何处理这单生意的。
# select()终于在readFds里面等来了事情，发现是s_fdWakeupRead里面有东西（注意此时仅有该句柄，新添加的s_fdListen还不在监控集合里面呢），就拿出来看看吧
# 先在timer_list里面看看有没有事情可干，发现此时里面没什么可干的
# 再去watch_table中看看吧，里面你两件事：s_wakeupfd_event和s_listen_event
# 还要看看这两件事是否都要处理，发现s_wakeupfd_event这个事情得马上处理，数据都已经发过来啦（FD_ISSET(）＝＝true），就放到待处理列表里吧，再来看看s_listen_event,这个里面还没有把具体的数据发送过来（由于刚刚建立socket监听，RILJ还没有连接请求发送过来），这件事就不必即可处理啦。
# 检查待处理列表（pending_list），依次处理里面的所有事情，调用他们的处理函数
# 处理完所有的事情后，这一轮处理就完成了
# 于是从新进行第一步，等待readFds中有事情发生，不过此时，readFds中除了s_fdWakeupRead外，又新加了一主儿s_fdListen.

由于readFds此时已经保存了s_fdListen句柄，所以当RILJ发送socket连接后，select就会从堵塞中返回，开始处理s_listen_event,等待读取socket发送过来的数据，从监听的socket中读到数据后，就创建一个命令事件s_commands_event，再添加到ril_event事件循环中去处理，命令事件的处理函数入口是processCommandsCallback().

`ril.cpp`
{{{class="brush: cpp"
static void listenCallback (int fd, short flags, void *param) {
    int is_phone_socket;
    RecordStream *p_rs;
    ......

    assert (s_fdCommand < 0);
    assert (fd == s_fdListen);

    //接受RILJ连接请求
    s_fdCommand = accept(s_fdListen, (sockaddr *) &peeraddr, &socklen);
    ......

    //创建一个RecordStream结构对象
    p_rs = record_stream_new(s_fdCommand, MAX_COMMAND_BYTES);

    //读到数据后，放到ril_event事件处理循环中处理，注意此事件persist=1
    //s_fdCommand添加到readFds中后，后续发来请求时，select(）就可以直接响应，而s_command_event又是持久存在的，所以就可以直接通过该事件的处理函数 processCommandsCallback()来处理啦。
    //而对于s_fdListen,处理完后，由于watch_list中已经没有对应的s_listen_event事件，虽然依然存在于readFds中，也无法接收新的RILJ连接了。
    ril_event_set (&s_commands_event, s_fdCommand, 1,
        processCommandsCallback, p_rs);

    rilEventAddWakeup (&s_commands_event);

    onNewCommandConnect();
}
}}}

处理发过来的数据
{{{class="brush: cpp"
static void processCommandsCallback(int fd, short flags, void *param) {
    RecordStream *p_rs;
    void *p_record;
    size_t recordlen;
    int ret;

    assert(fd == s_fdCommand);

    p_rs = (RecordStream *)param;

    //不断读取socket中的数据，直到socket关闭或读取出错
    for (;;) {
        /* loop until EAGAIN/EINTR, end of stream, or other error */
        ret = record_stream_get_next(p_rs, &p_record, &recordlen);

        if (ret == 0 && p_record == NULL) {
            /* end-of-stream */
            break;
        } else if (ret < 0) {
            break;
        } else if (ret == 0) { /* && p_record != NULL */
            //对请求进行处理
            processCommandBuffer(p_record, recordlen);
        }
    }

    //当socket被关闭时，重新添加监听
    if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
        /* fatal error or end-of-stream */
        if (ret != 0) {
            LOGE("error on reading command socket errno:%d\n", errno);
        } else {
            LOGW("EOS.  Closing command socket.");
        }

        close(s_fdCommand);
        s_fdCommand = -1;

        //因为s_commands_event为持久事件，这里手动删除
        ril_event_del(&s_commands_event);

        record_stream_free(p_rs);

        /* start listening for new connections again */
        //重新添加s_listen_event,准备接受新的连接
        rilEventAddWakeup(&s_listen_event);

        onCommandsSocketClosed();
    }
}
}}}

从上面代码可以看出，rild在接收到RILJ的连接请求后，就不再接收RILJ新的连接请求，只有在当前的连接中断或出现读取数据错误时，才会重新准备接受RILJ新的连接请求。

RILJ发送的请求最终由processCommandBuffer(）来处理

`ril.cpp`
{{{class="brush: cpp"
processCommandBuffer(void *buffer, size_t buflen) {
    Parcel p;
    status_t status;
    int32_t request;
    int32_t token;
    RequestInfo *pRI;
    int ret;

    p.setData((uint8_t *) buffer, buflen);

    // status checked at end
    status = p.readInt32(&request); //读取请求ID
    status = p.readInt32 (&token);  //读取该请求的序列号

    if (status != NO_ERROR) {
        LOGE("invalid request block");
        return 0;
    }

    if (request < 1 || request >= (int32_t)NUM_ELEMS(s_commands)) {
        LOGE("unsupported request code %d token %d", request, token);
        // FIXME this should perhaps return a response
        return 0;
    }

    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));

    pRI->token = token;
    pRI->pCI = &(s_commands[request]);//根据请求ID找到对应的处理函数

    ret = pthread_mutex_lock(&s_pendingRequestsMutex);
    assert (ret == 0);

    //将请求添加到请求列表中
    pRI->p_next = s_pendingRequests;
    s_pendingRequests = pRI;

    ret = pthread_mutex_unlock(&s_pendingRequestsMutex);
    assert (ret == 0);

    //调用对用的dispatchFunction()
    pRI->pCI->dispatchFunction(p, pRI);

    return 0;
}
}}}

s_commands是一个CommandInfo结构的数组，包含了ril_commands.h头文件
{{{class="brush: cpp"
static CommandInfo s_commands[] = {
#include "ril_commands.h"
};
}}}
而ril_command.h是一个映射表，包含所有rild支持的请求及对应的处理响应函数。这里的请求ID要与RILJ的RIL_Constants.java中ID号保持一致。

`ril_commands.h`
{{{class="brush: cpp"
    {0, NULL, NULL},                   //none
    {RIL_REQUEST_GET_SIM_STATUS, dispatchVoid, responseSimStatus},
    {RIL_REQUEST_ENTER_SIM_PIN, dispatchStrings, responseInts},
    {RIL_REQUEST_ENTER_SIM_PUK, dispatchStrings, responseInts},
    {RIL_REQUEST_ENTER_SIM_PIN2, dispatchStrings, responseInts},
    {RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts},
    {RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts},
    {RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts},
    {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, dispatchStrings, responseInts},
    {RIL_REQUEST_GET_CURRENT_CALLS, dispatchVoid, responseCallList},
    {RIL_REQUEST_DIAL, dispatchDial, responseVoid},
    {RIL_REQUEST_GET_IMSI, dispatchVoid, responseString},
    ......
}}}

rild将RIJL发送过来的请求封装为一个RequestInfo,并添加到内部维护的RequestInfo列表中。并根据请求的ID，在s_commands中找到对应的处理函数,调用对应的dispatchXXX(）函数，该函数最终调用libril提供的onRequest(）方法将请求交到libril手中。

我们以dispatchVoid为例
{{{class="brush: cpp"
/** Callee expects NULL */
static void
dispatchVoid (Parcel& p, RequestInfo *pRI) {
    //直接调用rillib的onRequest函数，将AT指令通过rillib发送到BP
    s_callbacks.onRequest(pRI->pCI->requestNumber, NULL, 0, pRI);
}
}}}

接下来，我们深入到libril看看onRequest(）是如何将消息发送到modem并接收modem响应的。
`reference-ril.c`
{{{class="brush: c"
static void
onRequest (int request, void *data, size_t datalen, RIL_Token t)
{
    ATResponse *p_response;
    int err;

    LOGD("onRequest: %s", requestToString(request));

    /* Ignore all requests except RIL_REQUEST_GET_SIM_STATUS
     * when RADIO_STATE_UNAVAILABLE.
     */
    if (sState == RADIO_STATE_UNAVAILABLE
        && request != RIL_REQUEST_GET_SIM_STATUS
    ) {
        RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
        return;
    }

    /* Ignore all non-power requests when RADIO_STATE_OFF
     * (except RIL_REQUEST_GET_SIM_STATUS)
     */
    if (sState == RADIO_STATE_OFF
        && !(request == RIL_REQUEST_RADIO_POWER
            || request == RIL_REQUEST_GET_SIM_STATUS)
    ) {
        RIL_onRequestComplete(t, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
        return;
    }

    switch (request) {
        case RIL_REQUEST_GET_SIM_STATUS: {
            RIL_CardStatus_v6 *p_card_status;
            char *p_buffer;
            int buffer_size;

            int result = getCardStatus(&p_card_status);
            if (result == RIL_E_SUCCESS) {
                p_buffer = (char *)p_card_status;
                buffer_size = sizeof(*p_card_status);
            } else {
                p_buffer = NULL;
                buffer_size = 0;
            }
            RIL_onRequestComplete(t, result, p_buffer, buffer_size);
            freeCardStatus(p_card_status);
            break;
        }
        case RIL_REQUEST_GET_CURRENT_CALLS:
            requestGetCurrentCalls(data, datalen, t);
            break;
        case RIL_REQUEST_DIAL:
            requestDial(data, datalen, t);
            break;
        case RIL_REQUEST_HANGUP:
            requestHangup(data, datalen, t);
            break;

        ......

        default:
            RIL_onRequestComplete(t, RIL_E_REQUEST_NOT_SUPPORTED, NULL, 0);
            break;
    }
}
}}}
libril根据发送过来的请求ID,调用对应的处理函数。

此处以RIL_REQUEST_GET_CURRENT_CALLS为例分析,这里终于看到了发到modem的AT指令了。

`reference-ril.c`
{{{class="brush: c"
static void requestGetCurrentCalls(void *data, size_t datalen, RIL_Token t)
{
    int err;
    ATResponse *p_response;
    ......
    //发送AT指令AT+CLCC,
    err = at_send_command_multiline ("AT+CLCC", "+CLCC:", &p_response);

    //直接处理AT命令的返回结果
    if (err != 0 || p_response->success == 0) {
        RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
        return;
    }

    /* count the calls */
    for (countCalls = 0, p_cur = p_response->p_intermediates
            ; p_cur != NULL
            ; p_cur = p_cur->p_next
    ) {
        countCalls++;
    }

    ......

    //调用该函数将处理结果反馈给RILJ
    RIL_onRequestComplete(t, RIL_E_SUCCESS, pp_calls,
            countValidCalls * sizeof (RIL_Call *));

    at_response_free(p_response);

#ifdef POLL_CALL_STATE
    if (countValidCalls) {  // We don't seem to get a "NO CARRIER" message from
                            // smd, so we're forced to poll until the call ends.
#else
    if (needRepoll) {
#endif
        RIL_requestTimedCallback (sendCallStateChanged, NULL, &TIMEVAL_CALLSTATEPOLL);
    }

    return;
error:
    RIL_onRequestComplete(t, RIL_E_GENERIC_FAILURE, NULL, 0);
    at_response_free(p_response);
}
}}}
函数调用了at_send_command_multiline(）来将AT命令发送到modem,参数p_responese用来保存返回的数据结果。接着往下跟:

`atchannel.c`
{{{class="brush: c"
int at_send_command_multiline (const char *command,
                                const char *responsePrefix,
                                 ATResponse **pp_outResponse)
{
    int err;

    err = at_send_command_full (command, MULTILINE, responsePrefix,
                                    NULL, 0, pp_outResponse);

    return err;
}

static int at_send_command_full (const char *command, ATCommandType type,
                    const char *responsePrefix, const char *smspdu,
                    long long timeoutMsec, ATResponse **pp_outResponse)
{
    /**
    * command: 表示发送的AT指令
    * 
    * type:用来标示期望的命令返回格式类型
    * typedef enum {
    *     NO_RESULT,   /* no intermediate response expected */
    *     NUMERIC,     /* a single intermediate response starting with a 0-9 */
    *     SINGLELINE,  /* a single intermediate response starting with a prefix */
    *     MULTILINE    /* multiple line intermediate response
    *                     starting with a prefix */
    * } ATCommandType;
    * 
    * responsePrefix: 反馈结果的前缀
    * timeoutMsec:
      超时时间，如果为0,表示无限等待modem反馈，如果不为0,则在timeoutMsec时间无响应后返回。
    * pp_outResponse:   用来保存反馈的结果
    */

    int err;

    if (0 != pthread_equal(s_tid_reader, pthread_self())) {
        /* cannot be called from reader thread */
        return AT_ERROR_INVALID_THREAD;
    }

    pthread_mutex_lock(&s_commandmutex);
    //发送命令
    err = at_send_command_full_nolock(command, type,
                    responsePrefix, smspdu,
                    timeoutMsec, pp_outResponse);

    pthread_mutex_unlock(&s_commandmutex);

    if (err == AT_ERROR_TIMEOUT && s_onTimeout != NULL) {
        s_onTimeout();
    }

    return err;
}

static int at_send_command_full_nolock (const char *command, ATCommandType type,
                    const char *responsePrefix, const char *smspdu,
                    long long timeoutMsec, ATResponse **pp_outResponse)
{
    int err = 0;
#ifndef USE_NP
    struct timespec ts;
#endif /*USE_NP*/

    //sp_response是一个全局变量，发送命令给modem时创建，从modem获取命令时置为null,如果发送命令时不为NULL,表示前一条命令未处理完毕。
    if(sp_response != NULL) {
        err = AT_ERROR_COMMAND_PENDING;
        goto error;
    }

    //将命令通过串口设备写入modem
    err = writeline (command);

    if (err < 0) {
        goto error;
    }

    s_type = type;
    s_responsePrefix = responsePrefix;
    s_smsPDU = smspdu;
    sp_response = at_response_new();

#ifndef USE_NP
    if (timeoutMsec != 0) {
        setTimespecRelative(&ts, timeoutMsec);
    }
#endif /*USE_NP*/

    //1
    等待处理结果，modem处理完该请求后，finalResponse就包含命令的处理结果
    while (sp_response->finalResponse == NULL && s_readerClosed == 0) {
        if (timeoutMsec != 0) {
#ifdef USE_NP
            err = pthread_cond_timeout_np(&s_commandcond, &s_commandmutex, timeoutMsec);
#else
            err = pthread_cond_timedwait(&s_commandcond, &s_commandmutex, &ts);
#endif /*USE_NP*/
        } else {
            //等待s_tid_reader线程发送s_commandcond,表示请求已经处理完
            err = pthread_cond_wait(&s_commandcond, &s_commandmutex);
        }

        if (err == ETIMEDOUT) {
            err = AT_ERROR_TIMEOUT;
            goto error;
        }
    }

    //将AT反馈结果返回
    if (pp_outResponse == NULL) {
        at_response_free(sp_response);
    } else {
        /* line reader stores intermediate responses in reverse order */
        reverseIntermediates(sp_response);
        *pp_outResponse = sp_response;
    }

    sp_response = NULL;

    if(s_readerClosed > 0) {
        err = AT_ERROR_CHANNEL_CLOSED;
        goto error;
    }

    err = 0;
error:
    clearPendingCommand();

    return err;
}
}}}
在使用writeLine(）将AT命令发送到串口后，函数便开始等待信号s_commandcond来获取命令的处理结果。而该信号又是在何时何地发送的呢？

大家是否记得前面讲到的rild调用libril的RIL_Init(）函数，创建的s_tid_reader线程，该线程用于读取modem发送过来的数据，自然也包括命令的反馈结果啦。如果记不太清楚了，请点击 <a href="#tag_s_tid_reader">【这里】</a>。

处理完发过来的请求后，通过RIL_onRequestComplete()函数将命令的处理结果发送给RILJ,该函数的分析请看这里<a href="#tag_onrequestcomplete">【这里】</a>

分析完毕。
