%template code_3
%toc

 = UNIX 环境高级编程 =

 == 第13章 守护进程 ==

=== 编写守护进程步骤 ===
# 调用umask将文件创建屏蔽字设置为0.
    由继承而来的文件创建屏蔽字可能拒绝设置某些权限.
# 调用fork,然后使父进程退出(exit).
    这样做实现了下面几点:
    * 第一,如果该守护进程是作为一条简单的shell命令启动的,那么父进程终止使得shell认为这条命令已经执行完毕
    * 第二,子进程继承了父进程的进程组ID,但具有一个新的进程ID,这就保证了子进程不是一个进程组的组长进程,这对于后面要做的setsid调用是必要的前提条件
# 调用setsid以创建一个新的会话.
    于是,子进程会:
    # 成为会话的首进程
    # 成为一个新的进程组的组长进程
    # 没有控制终端
    *此时可以再次调用fork,并使父进程终止,第二个子进程继续运行,这样就保证了该进程不是会话首进程,按照系统V规则,可以防止他获取控制终端*
# 将当前工作目录更改为根目录.
    从父进程继承过来的当前工作目录可能在一个装配文件系统中.因为守护进程通常在系统重启前一直运行,所有如果守护进程的当前工作目录在一个装配文件系统中,
    那么该文件系统就不能被卸载.这与装配文件系统的原意不符.
    另外,某些守护进程可能会把当前工作目录更改到某个指定目录,在那里做他的工作.
# 关闭不再使用的文件描述符
# 某些守护进城打开/dev/null使其具有文件描述符0,1,2,这样,任何一个试图读写标准输入输出出错的库例程都不会产生任何效果.

=== 日志消息系统 ===
Linux的日志消息系统为守护进程处理出错消息提供了方法.用户例程(守护进程)通过调用syslog函数产生日志消息,这些消息发送至UNIX域数据报套接字/dev/log
日志消息由syslogd守护进程读取.

{{{class="brush:c"
    #include <syslog.h>
    void openlog(const char *ident, int option, int facility)
    void syslog(int priority, const char *format, ...)
    void closelog(void)
    int setlogmask(int maskpri)
}}}
*调用openlog是可选的,如果不调用openlog,则在第一次调用syslog时,自动调用openlog.调用closelog也是可选的,他只是关闭曾被用于syslog守护进程通信的描述符*
消息的优先级(从高到低):LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG
在format中,每个%m都先被代换成对应于errno值的出错消息字符串(strerror)
例如:

{{{class="brush:c"
    syslog(LOG_ERR, "open error for %s:%m", filename);
}}}

=== 守护进程惯例 ===
# 若守护进程使用锁文件,那么该文件通常存放在/var/run目录中.锁文件的名称通常为name.pid, 其中name是该守护进程或服务的名字
# 若守护进程支持配置选项,那么配置文件通常在/etc目录中.配置文件的名字通常是name.conf,其中,name是该守护进程的名字.
# 守护进程可用命令行启动,当通常他们是由系统初始化脚本之一(/etc/rc*或/etc/init/d/*)启动的.如果在守护进程终止时,需要自动的重启他,则妇女可在/etc/inittab中为该守护进程包括_respawn记录项,这样init就将重新启动该守护进程.
# 若守护进程有一配置文件,那么当该守护进程启动时,他读取该文件,但在此之后,一般不会再查看该文件.若管理员更改了配置文件,则可能需要重新启动该守护进程,以便使配置文件生效.为避免此麻烦,某些守护进程将捕捉SIGHUP信号,当收到该信号时,重新读取配置文件.因为守护进程并不与终端结合,他们或者是无控制终端的会话首进程,或者是孤儿进程组的成员,所以守护进程并不期望接受SIGHUP,于是,他们可安全的重复使用他.
